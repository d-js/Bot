const chalk = require('chalk');
const { Console } = require('console');

/**
 * Colored Logger with Timestamps.
 * 
 * @author 2D#5773
 * @class ColoredLogger
 * @extends {console.Console}
 */

module.exports = class ColoredLogger extends Console {

	/**
     * @param {Object} opts
     * @argument {Boolean} [opts.timestampEnabled=true]
     * @argument {String} [opts.timestampColor='dim']
     */

	constructor(opts={}) {
		super(process.stdout, process.stderr);
		if(opts.file) this.ToFile = require('fs').createWriteStream(opts.file, {flags: 'a'});
		this.timestampEnabled = opts.timestampEnabled !== undefined ? opts.timestampEnabled : true;
		this.timestampColor = opts.timestampColor !== undefined ? opts.timestampColor : 'grey';
        this.process_name = opts.process_name !== undefined ? opts.process_name : 'NODE';
        this.process_color = opts.process_color !== undefined ? opts.process_color : 'green';
		this.levels = require('./levels');
		// super.log(`${chalk.red('[Colored] >')} ${chalk.green('BetaLogger =>')} 1.5.7`);
	}

	/**
     * Logs To The Console
     * 
     * @param {String} level 
     * @param {String} content 
     * @memberof ColoredLogger
     * @private
     */

	logger(level, content) {
		if(!level) throw this.error('No Level Given!');
		if(!content) throw this.error('No Content Given!');
		let mess = `${chalk[this.process_color](this.process_name.toUpperCase())} ${this.colorstamp} ${chalk[this.levels[level].color](`${this.levels[level].figure} ${chalk.underline(level)} =>`)} ${content}`;
		if(this.levels[level].ToFile && this.ToFile) this.ToFile.write(`${this.defaultstamp} ${this.levels[level].figure} ${level} => ${content}` + require('os').EOL);
		return super[this.levels[level].type](mess);
	}

	/**
     * Colored Timestamp
     * 
     * @returns {String}
     * @memberof ColoredLogger
     * @private
    */

	get colorstamp () {
		if(this.timestampEnabled) return `${chalk[this.timestampColor](`[${new Date().toLocaleString()}] >`)}`;
		else return '';
	}

	/** 
     * Default Timestamp
     * 
     * @returns {String}
     * @memberof ColoredLogger
     * @private
     */

	get defaultstamp() {
		if(this.timestampEnabled) return `[${new Date().toLocaleString()}] >`;
		else return '';
	}

	/**
     * Major - Critical Fault
     * Crashing Bugs, Unexpected Errors
     * 
     * @param {String} message
     * @returns {void}
     * @memberof ColoredLogger
     */

	emerg(message) {
		return this.logger('emerg', message);
	}

	/**
     * Major - Critical Error
     * trycatch | .catch()
     * 
     * @param {String} message 
     * @returns {void}
     * @memberof ColoredLogger
     * @example
     * try {
     *  // Code Here
     * } catch(e) {
     *  logger.error(e);
     * }
     */

	error(message) {
		return this.logger('error', message);
	}

	/**
     * Warning - Expected Errors
     * 
     * @param {String} message 
     * @returns {void}
     * @memberof ColoredLogger
     * @example
     * logger.warn('Optional: Description')
     */

	warn(message) {
		return this.logger('warn', message);
	}

	/**
     * Eval - Debugging Logscmkfkvmkfmkvmfkm kfk fkn b
     * 
     * @param {String} message
     * @returns {void}
     * @memberof ColoredLogger 
     */

	debug(message) {
		return this.logger('debug', message);
	}

	/**
     * Important Information
     *
     * @param {String} message
     * @returns {void}
     * @memberof ColoredLogger
     * @example
     * logger.notice('Connected!'); 
     */

	notice(message) {
		return this.logger('notice', message);
	}

	/**
     * Default Information
     * 
     * @param {String} message 
     * @returns {void}
     * @memberof ColoredLogger
     * @example
     * logger.info('Loaded 8 Files!');
     */

	info(message) {
		return this.logger('info', message);
	}

	/**
     * 
     * @param {String} message 
     * @returns {void}
     * @memberof ColoredLogger
     */

	watch(message) {
		return this.logger('watch', message);
	}

	/**
     * 
     * @param {String} message 
     * @returns {void}
     * @memberof ColoredLogger
     */

	pending(message) {
		return this.logger('pending', message);
	}

};